<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
  <head>
    <title>py.test features</title>
    <meta content="text/html;charset=ISO-8859-1" name="Content-Type"/>
    <link href="../style.css" media="screen" rel="stylesheet" type="text/css"/></head>
  <body>
    <div id="navspace">
      <div><a href="http://pylib.org"><img alt="py lib" height="57" id="pyimg" src="http://codespeak.net/img/pylib.png" width="77"/></a></div>
      <div id="menubar">
        <div>
          <div><a class="menu" href="../announce/release-1.3.4.html">1.3.4 ANN</a></div></div>
        <div>
          <div><a class="menu" href="../install.html">INSTALL</a></div></div>
        <div>
          <div><a class="menu" href="../contact.html">CONTACT</a></div></div>
        <div>
          <div><a class="menu" href="../changelog.html">CHANGELOG</a></div></div>
        <div>
          <div><a class="menu" href="../faq.html">FAQ</a></div></div>
        <div>
          <div>
            <h3>py.test:</h3>
            <div><a class="menu" href="index.html">Index</a></div>
            <div><a class="menu" href="quickstart.html">Quickstart</a></div>
            <div><a class="menu" href="features.html">Features</a></div>
            <div><a class="menu" href="funcargs.html">Funcargs</a></div>
            <div><a class="menu" href="plugin/index.html">Plugins</a></div>
            <div><a class="menu" href="customize.html">Customize</a></div>
            <div><a class="menu" href="talks.html">Tutorials</a></div><a class="menu" href="http://hudson.testrun.org">hudson-tests</a></div></div>
        <div>
          <div>
            <h3>supporting APIs:</h3>
            <div><a class="menu" href="../index.html">Index</a></div>
            <div><a class="menu" href="../path.html">py.path</a></div>
            <div><a class="menu" href="../code.html">py.code</a></div></div></div></div></div>
    <div id="contentspace">
<div class="document" id="py-test-feature-overview">
<h1 class="title">py.test feature overview</h1>

<div class="contents local topic" id="contents">
<ul class="simple">
<li><a class="reference internal" href="#mature-command-line-testing-tool" id="id1">mature command line testing tool</a></li>
<li><a class="reference internal" href="#extensive-easy-plugin-system" id="id2">extensive easy plugin system</a></li>
<li><a class="reference internal" href="#distributing-tests-to-your-cpus-and-ssh-accounts" id="id3">distributing tests to your CPUs and SSH accounts</a></li>
<li><a class="reference internal" href="#supports-several-testing-practises-and-methods" id="id4">supports several testing practises and methods</a></li>
<li><a class="reference internal" href="#integrates-well-with-ci-systems" id="id5">integrates well with CI systems</a></li>
<li><a class="reference internal" href="#no-boilerplate-test-functions-with-python" id="id6">no-boilerplate test functions with Python</a></li>
<li><a class="reference internal" href="#skip-or-expect-to-fail-a-test" id="id7">skip or expect-to-fail a test</a></li>
<li><a class="reference internal" href="#select-tests-by-keyword-test-name-search" id="id8">select tests by keyword / test name search</a></li>
<li><a class="reference internal" href="#looping-on-the-failing-test-set" id="id9">Looping on the failing test set</a></li>
</ul>
</div>
<div class="section" id="mature-command-line-testing-tool">
<h1><a class="toc-backref" href="#id1">mature command line testing tool</a></h1>
<p>py.test is a command line tool to collect, run and report about automated tests.  It runs well on Linux, Windows and OSX and on Python 2.4 through to 3.1 versions.
It is used in many projects, ranging from running 10 thousands of tests
to a few inlined tests on a command line script.  As of version 1.2 you can also
generate a no-dependency py.test-equivalent standalone script that you
can distribute along with your application.</p>
</div>
<div class="section" id="extensive-easy-plugin-system">
<h1><a class="toc-backref" href="#id2">extensive easy plugin system</a></h1>
<p>py.test delegates almost all aspects of its operation to <a class="reference external" href="plugin/index.html">plugins</a>.
It is <a class="reference external" href="http://bruynooghe.blogspot.com/2009/12/skipping-slow-test-by-default-in-pytest.html">suprisingly easy</a> to add command line options or
do other kind of add-ons and customizations.  This can
be done per-project or by distributing a global plugin.
One can can thus modify or add aspects for purposes such as:</p>
<ul class="simple">
<li>reporting extensions</li>
<li>customizing collection and execution of tests</li>
<li>running and managing non-python tests</li>
<li>managing domain-specific test state setup</li>
<li>adding non-python tests into the run, e.g. driven by data files</li>
</ul>
</div>
<div class="section" id="distributing-tests-to-your-cpus-and-ssh-accounts">
<h1><a class="toc-backref" href="#id3">distributing tests to your CPUs and SSH accounts</a></h1>
<p>Through the use of the separately released <a class="reference external" href="plugin/xdist.html">pytest-xdist</a> plugin you
can seemlessly distribute runs to multiple CPUs or remote computers
through SSH and sockets.  This plugin also offers a <tt class="docutils literal"><span class="pre">--looponfailing</span></tt>
mode which will continously re-run only failing tests in a subprocess.</p>
</div>
<div class="section" id="supports-several-testing-practises-and-methods">
<h1><a class="toc-backref" href="#id4">supports several testing practises and methods</a></h1>
<p>py.test supports many testing methods conventionally used in
the Python community. It runs traditional <a class="reference external" href="http://docs.python.org/library/unittest.html">unittest.py</a>,
<a class="reference external" href="http://docs.python.org/library/doctest.html">doctest.py</a>, supports <a class="reference external" href="xunit_setup.html">xUnit style setup</a> and <a class="reference external" href="http://somethingaboutorange.com/mrl/projects/nose/">nose</a> specific
setups and test suites.  It offers minimal no-boilerplate model
for configuring and deploying tests written as simple Python
functions or methods.  It also integrates <a class="reference external" href="plugin/figleaf.html">coverage testing
with figleaf</a> or <a class="reference external" href="plugin/oejskit.html">Javasript unit- and functional testing</a>.</p>
</div>
<div class="section" id="integrates-well-with-ci-systems">
<h1><a class="toc-backref" href="#id5">integrates well with CI systems</a></h1>
<p>py.test can produce JUnitXML style output as well as formatted
&quot;resultlog&quot; files that can be postprocessed by Continous Integration
systems such as Hudson or Buildbot easily.  It also provides command
line options to control test configuration lookup behaviour or ignoring
certain tests or directories.</p>
</div>
<div class="section" id="no-boilerplate-test-functions-with-python">
<h1><a class="toc-backref" href="#id6">no-boilerplate test functions with Python</a></h1>
<div class="section" id="automatic-python-test-discovery">
<span id="autocollect"></span><h2>automatic Python test discovery</h2>
<p>By default, all python modules with a <tt class="docutils literal"><span class="pre">test_*.py</span></tt>
filename are inspected for finding tests:</p>
<ul class="simple">
<li>functions with a name beginning with <tt class="docutils literal">test_</tt></li>
<li>classes with a leading <tt class="docutils literal">Test</tt> name and <tt class="docutils literal">test</tt> prefixed methods.</li>
<li><tt class="docutils literal">unittest.TestCase</tt> subclasses</li>
</ul>
</div>
<div class="section" id="parametrizing-test-functions-and-functional-testing">
<h2>parametrizing test functions and functional testing</h2>
<p>py.test offers the unique <a class="reference external" href="funcargs.html">funcargs mechanism</a> for setting up
and passing project-specific objects to Python test functions.
Test Parametrization happens by triggering a call to the same test
function with different argument values.  For doing fixtures
using the funcarg mechanism makes your test and setup code
more efficient and more readable. This is especially true
for functional tests which might depend on command line
options and a setup that needs to be shared across
a whole test run.</p>
</div>
<div class="section" id="per-test-capturing-of-output-including-subprocesses">
<h2>per-test capturing of output, including subprocesses</h2>
<p>By default, <tt class="docutils literal">py.test</tt> captures all writes to stdout/stderr.
Output from <tt class="docutils literal">print</tt> statements as well as from subprocesses
is <a class="reference external" href="plugin/capture.html">captured</a>.  When a test fails, the associated captured outputs are shown.
This allows you to put debugging print statements in your code without
being overwhelmed by all the output that might be generated by tests
that do not fail.</p>
</div>
<div class="section" id="assert-with-the-assert-statement">
<h2>assert with the <tt class="docutils literal">assert</tt> statement</h2>
<p><tt class="docutils literal">py.test</tt> allows to use the standard python
<tt class="docutils literal">assert statement</tt> for verifying expectations
and values in Python tests.  For example, you can
write the following in your tests:</p>
<pre class="literal-block">
assert hasattr(x, 'attribute')
</pre>
<p>to state that your object has a certain <tt class="docutils literal">attribute</tt>. In case this
assertion fails you will see the value of <tt class="docutils literal">x</tt>.  Intermediate
values are computed by executing the assert expression a second time.
If you execute code with side effects, e.g. read from a file like this:</p>
<pre class="literal-block">
assert f.read() != '...'
</pre>
<p>then you may get a warning from pytest if that assertions
first failed and then succeeded.</p>
</div>
<div class="section" id="asserting-expected-exceptions">
<h2>asserting expected exceptions</h2>
<p>In order to write assertions about exceptions, you can use
<tt class="docutils literal">py.test.raises</tt> as a context manager like this:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">with</span> py<span style="color: #666666">.</span>test<span style="color: #666666">.</span>raises(<span style="color: #D2413A; font-weight: bold">ZeroDivisionError</span>):
    <span style="color: #666666">1</span> <span style="color: #666666">/</span> <span style="color: #666666">0</span>
</pre></div>
<p>and if you need to have access to the actual exception info you may use:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #008000; font-weight: bold">with</span> py<span style="color: #666666">.</span>test<span style="color: #666666">.</span>raises(<span style="color: #D2413A; font-weight: bold">RuntimeError</span>) <span style="color: #008000; font-weight: bold">as</span> excinfo:
    <span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">f</span>():
        f()
    f()

<span style="color: #408080; font-style: italic"># do checks related to excinfo.type, excinfo.value, excinfo.traceback</span>
</pre></div>
<p>If you want to write test code that works on Python2.4 as well,
you may also use two other ways to test for an expected exception:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%">py<span style="color: #666666">.</span>test<span style="color: #666666">.</span>raises(ExpectedException, func, <span style="color: #666666">*</span>args, <span style="color: #666666">**</span>kwargs)
py<span style="color: #666666">.</span>test<span style="color: #666666">.</span>raises(ExpectedException, <span style="color: #BA2121">&quot;func(*args, **kwargs)&quot;</span>)
</pre></div>
<p>both of which execute the specified function with args and kwargs and
asserts that the given <tt class="docutils literal">ExpectedException</tt> is raised.  The reporter will
provide you with helpful output in case of failures such as <em>no
exception</em> or <em>wrong exception</em>.</p>
</div>
<div class="section" id="information-rich-tracebacks-pdb-introspection">
<h2>information-rich tracebacks, PDB introspection</h2>
<p>A lot of care is taken to present useful failure information
and in particular nice and concise Python tracebacks.  This
is especially useful if you need to regularly look at failures
from nightly runs, i.e. are detached from the actual test
running session.  Here are <a class="reference external" href="http://paste.pocoo.org/show/134814/">example tracebacks</a> for a number of failing
test functions.  You can modify traceback printing styles through the
command line.  Using the <cite>--pdb`</cite> option you can automatically activate
a PDB <a class="reference external" href="http://docs.python.org/lib/module-pdb.html">Python debugger</a> when a test fails.</p>
</div>
</div>
<div class="section" id="skip-or-expect-to-fail-a-test">
<h1><a class="toc-backref" href="#id7">skip or expect-to-fail a test</a></h1>
<p>py.test has a dedicated <a class="reference external" href="plugin/skipping.html">skipping plugin</a> that allows to define</p>
<ul class="simple">
<li>define &quot;skip&quot; outcomes indicating a platform or a
dependency mismatch.</li>
<li>&quot;xfail&quot; outcomes indicating an &quot;expected failure&quot; either with
with or without running a test.</li>
<li>skip and xfail outcomes can be applied at module, class or method
level or even only for certain argument sets of a parametrized function.</li>
</ul>
</div>
<div class="section" id="select-tests-by-keyword-test-name-search">
<h1><a class="toc-backref" href="#id8">select tests by keyword / test name search</a></h1>
<p id="selection-by-keyword">You can selectively run tests by specifiying a keyword
on the command line.  Examples:</p>
<pre class="literal-block">
py.test -k test_simple
py.test -k &quot;-test_simple&quot;
</pre>
<p>will run all tests matching (or not matching) the
&quot;test_simple&quot; keyword.  Note that you need to quote
the keyword if &quot;-&quot; is recognized as an indicator
for a commandline option.  Lastly, you may use:</p>
<pre class="literal-block">
py.test. -k &quot;test_simple:&quot;
</pre>
<p>which will run all tests after the expression has <em>matched once</em>, i.e.
all tests that are seen after a test that matches the &quot;test_simple&quot;
keyword.</p>
<p>By default, all filename parts and
class/function names of a test function are put into the set
of keywords for a given test.  You can specify additional
kewords like this:</p>
<div class="highlight" style="background: #f8f8f8"><pre style="line-height: 125%"><span style="color: #AA22FF">@py.test.mark.webtest</span>
<span style="color: #008000; font-weight: bold">def</span> <span style="color: #0000FF">test_send_http</span>():
    <span style="color: #666666">...</span>
</pre></div>
<p>and then use those keywords to select tests.  See the <a class="reference external" href="plugin/mark.html">pytest_keyword</a>
plugin for more information.</p>
</div>
<div class="section" id="looping-on-the-failing-test-set">
<h1><a class="toc-backref" href="#id9">Looping on the failing test set</a></h1>
<p><tt class="docutils literal">py.test <span class="pre">--looponfailing</span></tt> (implemented through the external
<a class="reference external" href="plugin/xdist.html">pytest-xdist</a> plugin) allows to run a test suite,
memorize all failures and then loop over the failing set
of tests until they all pass.  It will re-start running
the tests when it detects file changes in your project.</p>
</div>
</div>
</div>
<script type="text/javascript">
var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
</script>
<script type="text/javascript">
try {
var pageTracker = _gat._getTracker("UA-7597274-3");
pageTracker._trackPageview();
} catch(err) {}</script>
</body></html>